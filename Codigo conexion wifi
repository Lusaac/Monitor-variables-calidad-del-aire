// ===== Librerías =====
#include <WiFi.h>
#include <PubSubClient.h>
#include "virtuabotixRTC.h"
#include <SparkFunCCS811.h>
#include <ClosedCube_HDC1080.h>
#include <Wire.h>
#include <BH1750.h>
#include <OneWire.h>
#include <DallasTemperature.h>

// ===== Configuración WiFi y ThingsBoard =====
const char* ssid = "Nombre_de_red";
const char* password = "Constraseña_de_red";
const char* mqttServer = "server_de_thingsboard"; // o "demo.thingsboard.io"
const char* deviceToken = "Tu_token ";  //aire_calidad para el preterminado

WiFiClient espClient;
PubSubClient client(espClient);

unsigned long previousMillis = 0;
const unsigned long interval = 5000; // enviar cada 5s

// ===== Pines y Direcciones =====
#define CCS811_ADDR 0x5A
#define RTC_CLK_PIN 27
#define RTC_DAT_PIN 14
#define RTC_RST_PIN 26
#define ONE_WIRE_BUS 15
#define MQ7_ANALOG_PIN 34
#define I2C_SDA 21
#define I2C_SCL 22

// ===== Parámetros MQ-7 =====
const float R1 = 2200.0;
const float R2 = 3300.0;
const float RL = 1000.0;
const float VCC_MQ7 = 5.0;
const float RS_BASE_LINE = 214.6;
const float CO_BASE_LINE = 400.0;

// ===== Objetos =====
virtuabotixRTC myRTC(RTC_CLK_PIN, RTC_DAT_PIN, RTC_RST_PIN);
CCS811 myCCS811(CCS811_ADDR);
ClosedCube_HDC1080 myHDC1080;
OneWire oneWireObjeto(ONE_WIRE_BUS);
DallasTemperature sensorDS18B20(&oneWireObjeto);
BH1750 lightMeter;

// ===== Variables =====
float tempC = 0;
float hum = 0;
int co2 = 0;
int tvoc = 0;
double co = 0;
float lux = 0;
float Rs = 0;
float temp2 = 0;

bool ccs811Available = false;
bool hdc1080Available = false;
bool bh1750Available = false;

// ===== SETUP =====
void setup() {
  Serial.begin(115200);
  Wire.begin(I2C_SDA, I2C_SCL);
  pinMode(MQ7_ANALOG_PIN, INPUT);

  // Conectar WiFi
  WiFi.begin(ssid, password);
  Serial.print("Conectando al WiFi...");
  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.print(".");
  }
  Serial.println("\n Conectado al WiFi");

  client.setServer(mqttServer, 1883);
  reconnectMQTT();

  // Inicializar sensores
  initializeSensors();

  Serial.println(F("===== Monitor Ambiental ESP32 ====="));
  Serial.println(F("Fecha,Hora,Temp(C),HR(%),CO2(ppm),tVOC(ppb),CO(ppm),Luz(lx),Temp2(C)"));
}

// ===== Inicializar sensores =====
void initializeSensors() {
  if (checkI2CDevice(0x23)) {
    lightMeter.begin();
    bh1750Available = true;
  }
  if (checkI2CDevice(0x40)) {
    myHDC1080.begin(0x40);
    hdc1080Available = true;
  }
  if (checkI2CDevice(0x5A) && myCCS811.begin()) {
    ccs811Available = true;
  }
  sensorDS18B20.begin();
}

bool checkI2CDevice(byte address) {
  Wire.beginTransmission(address);
  return (Wire.endTransmission() == 0);
}

// ===== LOOP =====
void loop() {
  if (!client.connected()) reconnectMQTT();
  client.loop();

  unsigned long currentMillis = millis();
  if (currentMillis - previousMillis >= interval) {
    previousMillis = currentMillis;

    readSensors();
    printData();
    sendData();
  }
}

// ===== Lectura MQ-7 =====
float readMQ7Rs() {
  int adc_MQ = analogRead(MQ7_ANALOG_PIN);
  if (adc_MQ == 0) return 0;
  float voltaje_esp32 = adc_MQ * (3.3 / 4095.0);
  float voltaje_MQ7 = voltaje_esp32 * (R1 + R2) / R2;
  return RL * (VCC_MQ7 - voltaje_MQ7) / voltaje_MQ7;
}

// ===== Leer sensores =====
void readSensors() {
  if (hdc1080Available) {
    tempC = myHDC1080.readTemperature();
    hum = myHDC1080.readHumidity();
  }
  if (ccs811Available && myCCS811.dataAvailable()) {
    myCCS811.readAlgorithmResults();
    co2 = myCCS811.getCO2();
    tvoc = myCCS811.getTVOC();
    if (hdc1080Available) myCCS811.setEnvironmentalData(hum, tempC);
  }
  if (bh1750Available) {
    lux = lightMeter.readLightLevel();
  }
  Rs = readMQ7Rs();
  if (Rs > 0) {
    float ratio = Rs / RS_BASE_LINE;
    co = CO_BASE_LINE * pow(ratio, -2.5);
  }
  sensorDS18B20.requestTemperatures();
  temp2 = sensorDS18B20.getTempCByIndex(0);
}

// ===== Imprimir en Serial =====
void printData() {
  myRTC.updateTime();
  Serial.print(myRTC.dayofmonth); Serial.print("/");
  Serial.print(myRTC.month); Serial.print("/");
  Serial.print(myRTC.year); Serial.print(",");

  Serial.printf("%02d:%02d:%02d,", myRTC.hours, myRTC.minutes, myRTC.seconds);
  Serial.print(tempC, 2); Serial.print(",");
  Serial.print(hum, 2); Serial.print(",");
  Serial.print(co2); Serial.print(",");
  Serial.print(tvoc); Serial.print(",");
  Serial.print(co, 1); Serial.print(",");
  Serial.print(lux, 0); Serial.print(",");
  Serial.println(temp2, 2);
}

// ===== Enviar a ThingsBoard =====
void sendData() {
  String payload = "{";
  payload += "\"temp\":" + String(tempC, 2) + ",";
  payload += "\"hum\":" + String(hum, 2) + ",";
  payload += "\"co2\":" + String(co2) + ",";
  payload += "\"tvoc\":" + String(tvoc) + ",";
  payload += "\"co\":" + String(co, 1) + ",";
  payload += "\"lux\":" + String(lux, 0) + ",";
  payload += "\"temp2\":" + String(temp2, 2);
  payload += "}";

  Serial.print(" Enviando a ThingsBoard: ");
  Serial.println(payload);
  client.publish("v1/devices/me/telemetry", (char*)payload.c_str());
}

// ===== Reconexión MQTT =====
void reconnectMQTT() {
  while (!client.connected()) {
    Serial.print("Conectando a ThingsBoard... ");
    if (client.connect("ESP32Client", deviceToken, NULL)) {
      Serial.println("Conectado a ThingsBoard!");
    } else {
      Serial.print("Fallo, rc=");
      Serial.print(client.state());
      Serial.println(" Reintentando en 5s...");
      delay(5000);
    }
  }
}
